# C语言自研编译器技术方案

## 项目概述

本项目旨在开发一个用Rust编写的自研C语言编译器，将C源代码转换为Bisheng的token流、AST、IR，最终生成RISC-V汇编代码。项目采用模块化设计，支持完整的编译流程验证和自动化测试。整个编译器将实现从源代码到目标代码的完整转换链路，确保与Bisheng工具链的兼容性和一致性。

### 设计理念与目标

本项目的核心设计理念是构建一个高质量、可维护、可扩展的编译器系统。我们选择Rust语言作为实现语言，主要考虑其内存安全性、并发安全性和零成本抽象特性，这些特性对于编译器这种系统级软件至关重要。Rust的所有权系统能够有效防止内存泄漏和悬空指针，生命周期管理确保引用始终有效，这对于处理复杂的AST和IR数据结构特别重要。

项目的技术目标包括：
- 实现完整的C语言子集支持
- 确保与Bisheng工具链的完全兼容
- 建立高效的代码生成管道
- 提供丰富的调试和优化信息

我们追求的目标不仅是功能完整性，更重要的是代码质量和系统稳定性。通过模块化设计，我们希望建立一个易于理解、易于测试、易于扩展的编译器架构。

### 技术选型理由

选择Rust作为实现语言的原因是多方面的：

1. **强大的类型系统**：能够在编译时捕获许多运行时错误，这对于编译器这种关键基础设施软件非常重要
2. **性能优势**：性能接近C/C++，但提供了更好的内存安全性
3. **生态系统**：Rust的生态系统正在快速发展，有丰富的库和工具支持
4. **错误处理**：Rust的错误处理机制（Result类型）非常适合编译器中的错误处理需求

选择RISC-V作为目标架构的原因包括：
- RISC-V是一个开放、模块化的指令集架构，具有良好的扩展性和灵活性
- RISC-V的指令集相对简单，便于实现代码生成
- RISC-V在学术界和工业界都有广泛应用，有丰富的工具链支持

### ANTLR 集成方案

为了简化语法分析器的开发，我们计划引入 ANTLR (ANother Tool for Language Recognition) 作为解析器生成器：

**ANTLR 的优势：**
- **成熟的语法定义**：支持 EBNF 语法，可以精确描述 C 语言的语法规则
- **自动生成解析器**：根据语法文件自动生成词法分析器和语法分析器，减少手工编码错误
- **丰富的目标语言支持**：支持生成 Rust 代码，与我们的技术栈完美匹配
- **强大的错误处理**：内置错误恢复机制和详细的错误报告
- **活跃的社区**：有大量的语法示例和最佳实践可以参考

**集成步骤：**
1. **语法文件编写**：创建 `grammars/c.g4` 文件，定义 C 语言的完整语法
2. **依赖配置**：在 `Cargo.toml` 中添加 ANTLR 运行时依赖
3. **构建脚本**：编写构建脚本自动生成解析器代码
4. **接口适配**：将生成的解析器代码集成到现有的模块架构中

**语法文件结构：**
```
grammars/
├── c.g4              # C语言主语法文件
├── expressions.g4    # 表达式语法
├── statements.g4     # 语句语法
└── declarations.g4   # 声明语法
```

**构建流程：**
- 在 `cargo build` 时自动运行 ANTLR 工具
- 生成的代码放在 `src/generated/` 目录下
- 通过 `build.rs` 脚本管理代码生成过程

## 技术架构

### 编译流程

```
C源代码 → Token流 → AST → Bisheng Token流 → Bisheng AST → Bisheng IR → 自定义IR → RISC-V汇编
```

整个编译过程分为五个核心阶段：

1. **词法分析阶段**：负责将C源代码转换为Token流，识别关键字、标识符、字面量、运算符等基本语言元素
2. **语法分析阶段**：构建抽象语法树(AST)，建立代码的层次结构
3. **Bisheng转换阶段**：将我们的AST转换为Bisheng格式，确保与目标工具链的兼容性
4. **中间代码生成阶段**：创建自定义的IR表示，为后续优化和代码生成做准备
5. **目标代码生成阶段**：将IR转换为RISC-V汇编代码

### 架构设计原则

我们的架构设计遵循几个核心原则：

- **模块化原则**：每个编译阶段都有独立的模块负责，模块间通过清晰的接口进行交互，这样便于测试、调试和维护
- **可扩展性原则**：架构设计考虑了未来可能的功能扩展，如支持新的语言特性、新的目标架构等
- **性能原则**：在保证代码质量的前提下，我们追求编译效率和生成代码的性能
- **兼容性原则**：确保与Bisheng工具链的完全兼容，这是项目成功的关键

### 数据流设计

编译器的数据流设计考虑了数据的不可变性和传递效率。Token流在词法分析阶段生成后，作为不可变数据传递给语法分析器。AST在语法分析阶段构建，同样作为不可变数据传递给语义分析器。这种设计确保了数据的一致性和线程安全性。

在各个阶段之间，我们使用序列化技术（如serde）进行数据传递，这样既保证了数据的完整性，又便于调试和测试。

## 文件架构设计

项目采用清晰的模块化架构，每个编译阶段都有独立的模块负责：

- **主程序入口**：位于`src/main.rs`，负责协调各个模块的调用和流程控制
- **词法分析器模块**：`src/lexer/`包含Token定义、词法分析器实现和关键字处理，是整个编译流程的起点
- **语法分析器模块**：`src/parser/`负责构建AST，包含AST节点定义、递归下降解析器和运算符优先级处理
- **语义分析模块**：`src/semantic/`进行类型检查和符号表管理，确保代码的语义正确性
- **Bisheng集成模块**：`src/bisheng/`负责格式转换，将我们的内部表示转换为Bisheng兼容的格式
- **中间表示模块**：`src/ir/`定义IR指令、基本块和函数结构，为代码优化提供基础
- **RISC-V代码生成模块**：`src/riscv/`实现最终的汇编代码生成，包括寄存器分配和指令选择
- **错误处理模块**：`src/error/`提供统一的错误类型定义和处理机制
- **工具函数模块**：`src/utils/`包含各种辅助函数和通用工具

此外，项目还包含示例代码目录`examples/`、测试文件目录`tests/`、验证脚本目录`scripts/`、工具脚本目录`tools/`、输出目录`out/`和语法文件目录`grammars/`，形成完整的开发和测试环境。

### 模块依赖关系设计

模块间的依赖关系设计遵循依赖倒置原则，高层模块不依赖低层模块，而是依赖抽象接口。例如，主程序只依赖各个模块的公共接口，而不直接依赖具体实现。这种设计使得模块可以独立开发和测试，也便于后续的模块替换和重构。

我们使用Rust的模块系统来管理依赖关系，通过`pub`关键字控制模块的可见性，确保模块间的接口清晰明确。

### 错误处理架构

错误处理架构采用分层设计，每个模块都有自己的错误类型，这些错误类型都实现了统一的Error trait。错误信息包含详细的上下文信息，如错误位置、错误类型、错误描述等。

我们使用`thiserror`库来简化错误类型的定义，使用`anyhow`库来简化错误处理代码。错误恢复策略包括错误跳过、错误修正和错误报告等，确保编译器能够在遇到错误时继续工作，为用户提供有用的错误信息。

## 项目里程碑规划

### M0: 项目骨架搭建 ✅ (已完成)

项目骨架搭建阶段已经完成，包括：
- 创建完整的项目目录结构
- 初始化Cargo.toml配置文件
- 创建所有模块的基础文件
- 实现最小可编译骨架
- 添加冒烟测试
- 设置基本的错误处理框架

这个阶段为后续开发奠定了坚实的基础，确保项目结构清晰、模块划分合理，并且能够进行基本的编译和测试。

在这个阶段，我们特别注重了项目结构的合理性和可维护性。每个模块都有清晰的职责划分，模块间的接口设计考虑了未来的扩展需求。错误处理框架的建立为后续开发提供了统一的错误处理机制，确保错误信息的一致性和可读性。

### M1: 实验一：词法分析器实现 🔄 (已完成)

词法分析器实现阶段正在进行中，这是编译器的第一个重要组件。目前已经完成了基础Token类型的定义，包括标识符、关键字、整数字面量、运算符和分隔符等基本元素。

接下来需要实现：
- 字符串字面量、字符字面量和浮点数字面量的支持，完善Token类型系统
- 位置追踪与错误恢复功能，包括行号列号记录、错误Token跳过策略和错误位置报告机制
- 词法分析器的核心功能，包括`Lexer::tokenize()`方法的实现、输入流处理和状态机实现
- 测试覆盖，建立单元测试、快照测试和边界情况测试

词法分析器的设计采用了状态机模式，每个状态对应一种Token类型的识别。这种设计使得词法分析器能够高效地处理各种输入，同时保持代码的清晰性。位置追踪功能对于错误报告和调试非常重要，我们使用专门的Location结构来记录每个Token的位置信息。错误恢复策略包括跳过无效字符、尝试重新同步等，确保词法分析器能够在遇到错误时继续工作。

### M2: 实验二：语法分析器实现 📋 (进行中)

语法分析器实现阶段计划在词法分析器完成后开始，这是编译器的第二个核心组件。

**ANTLR 集成实现：**
- 使用 ANTLR 4 语法文件定义 C 语言的完整语法规则
- 自动生成词法分析器和语法分析器代码
- 集成 ANTLR 运行时库，处理语法树遍历和错误恢复

**AST节点定义**将包括：
- 表达式节点
- 语句节点
- 声明节点
- 函数定义节点
- 程序节点

**解析器架构**将基于 ANTLR 生成的代码，结合自定义的 AST 构建逻辑：
- 利用 ANTLR 的 LL(*) 解析算法处理复杂的语法结构
- 实现自定义的 AST 访问者模式，将 ANTLR 语法树转换为我们的 AST
- 支持运算符优先级和结合性的自动处理

**错误处理与恢复机制**将利用 ANTLR 的内置功能：
- 语法错误自动检测和报告
- 错误恢复策略（错误同步、错误跳过等）
- 详细的错误位置信息和上下文提示

语法分析器的设计采用了 ANTLR 生成 + 自定义 AST 构建的混合方式。ANTLR 负责处理复杂的语法解析，包括运算符优先级、左递归消除等复杂问题。我们专注于 AST 的设计和语义信息的提取，通过访问者模式将 ANTLR 的语法树转换为我们的内部表示。这种设计既利用了 ANTLR 的成熟性和稳定性，又保持了我们对 AST 结构的完全控制。

### M3: 实验三：语义分析器实现 📋 (计划中)

语义分析器实现阶段将建立完整的类型系统和符号表管理。

**符号表管理**包括：
- 作用域栈的实现
- 符号查找和插入功能
- 确保变量和函数的作用域规则得到正确执行

**类型系统**将定义基本类型、实现类型检查和类型推导，为后续的代码生成提供类型信息。

**语义检查**将验证变量声明、函数调用和返回路径的正确性，确保代码符合C语言的语义规则。

**解糖处理**将把复杂的语言结构转换为简单的IR表示，为一元运算和二元运算的规范化做准备。

语义分析器的设计采用了多遍分析的方式：
- 第一遍：建立符号表和作用域信息
- 第二遍：进行类型检查和语义验证
- 第三遍：进行解糖处理

符号表使用哈希表实现，支持快速查找和插入。作用域栈使用栈结构实现，支持嵌套作用域的正确处理。类型系统支持基本类型、指针类型、数组类型和函数类型等，为后续的代码生成提供完整的类型信息。

### M4: 实验四：Bisheng集成与IR管线 📋 (计划中)

Bisheng集成与IR管线阶段将实现与Bisheng工具链的深度集成。

**Bisheng格式转换**将建立C AST到Bisheng Token、AST和IR的映射关系，确保格式的兼容性。

**自定义IR生成**将实现：
- 基本块构建
- 控制流图构建
- 指令选择

**中间代码优化**将实现死代码消除、常量折叠和基本块合并等优化技术，提高生成代码的质量。

Bisheng集成的设计考虑了格式兼容性和性能要求。我们建立了详细的映射规范，定义了C语言结构到Bisheng格式的转换规则。IR的设计采用了SSA（静态单赋值）形式，这种形式便于进行各种优化。基本块构建考虑了控制流的复杂性，支持条件分支、循环和函数调用等结构。优化技术的选择基于实际效果和实现复杂度的平衡，优先实现效果明显的优化。

### M5: 实验五：RISC-V代码生成 📋 (计划中)

RISC-V代码生成阶段将实现从IR到目标汇编的转换。

**指令选择**将建立IR指令到RISC-V指令的映射关系，处理复杂指令的分解。

**寄存器分配**将实现线性扫描算法，进行活跃变量分析和寄存器溢出处理，确保代码的正确性和效率。

**汇编输出**将实现指令格式化、标签处理和伪指令支持，生成标准的RISC-V汇编代码。

RISC-V代码生成的设计考虑了目标架构的特点和性能要求。指令选择使用模式匹配的方式，将IR操作映射到最优的RISC-V指令序列。寄存器分配采用线性扫描算法，这种算法在性能和实现复杂度之间取得了良好的平衡。活跃变量分析使用数据流分析技术，确保寄存器分配的正确性。汇编输出支持标准的RISC-V汇编格式，包括标签、指令和伪指令等。

### M6: 实验六：优化与质量提升 📋 (计划中)

优化与质量提升阶段将实现各种代码优化技术，包括常量传播、循环优化和内联优化等。

**错误处理改进**将提供：
- 详细的错误信息
- 错误恢复策略
- 多错误报告功能

这个阶段将重点关注编译器的性能和稳定性，确保生成的代码质量和编译效率。

优化的设计基于实际效果和实现复杂度的分析。常量传播能够消除不必要的计算，提高运行时性能。循环优化包括循环展开、循环向量化等技术，能够显著提升循环代码的性能。内联优化能够减少函数调用开销，提高程序执行效率。错误处理的改进包括错误分类、错误优先级和错误上下文等，为用户提供更好的调试体验。

### M7: 实验七：工具链集成 📋 (计划中)

工具链集成阶段将建立完整的开发工具链。

**CLI接口**将支持子命令如lex、parse、ir、codegen等，提供输出格式选项和调试信息输出。

**日志系统**将记录编译过程日志和调试信息，便于问题诊断和性能分析。

**配置文件支持**将允许用户自定义编译选项和参数，提高工具的灵活性。

工具链集成的设计考虑了用户体验和开发效率。CLI接口使用clap库实现，提供了丰富的命令行选项和自动生成的帮助信息。日志系统使用结构化日志，支持不同级别的日志输出和日志过滤。配置文件支持JSON和TOML格式，允许用户自定义编译选项、优化级别和目标架构等参数。

## 已完成工作详细记录

### 项目初始化 ✅

项目初始化阶段已经完成，Cargo.toml配置文件定义了完整的基础依赖：

- **anyhow**：用于错误处理
- **thiserror**：用于自定义错误类型
- **serde**：用于序列化支持
- **serde_json**：用于JSON序列化
- **clap**：用于命令行参数解析

这些依赖为项目提供了强大的基础设施支持。Rust工具链配置已经完成，rust-toolchain.toml文件确保了开发环境的一致性。

依赖选择经过了仔细的评估和测试：
- anyhow提供了简洁的错误处理接口，特别适合快速原型开发
- thiserror提供了类型安全的错误定义，确保错误类型的一致性和可维护性
- serde提供了强大的序列化支持，便于数据的存储和传输
- clap提供了丰富的命令行参数处理功能，支持子命令、选项和参数验证等

### 模块骨架搭建 ✅

模块骨架搭建阶段已经完成，所有核心模块的基础结构都已经建立：

- **主程序入口**：src/main.rs包含了完整的模块声明和程序流程控制
- **词法分析器模块**：src/lexer/包含了Token定义、词法分析器实现和关键字处理的基础结构
- **语法分析器模块**：src/parser/包含了AST定义和解析器框架，为语法分析提供基础
- **语义分析模块**：src/semantic/包含了分析器和符号表框架，为语义检查做准备
- **Bisheng集成模块**：src/bisheng/包含了转换接口定义，为后续的格式转换做准备
- **中间表示模块**：src/ir/包含了IR指令和基本块定义，为代码生成提供基础
- **RISC-V代码生成模块**：src/riscv/包含了代码生成器框架，为最终的汇编输出做准备
- **错误处理模块**：src/error/包含了统一错误类型定义，确保错误处理的一致性
- **工具函数模块**：src/utils/包含了各种辅助函数，为其他模块提供通用功能支持

模块设计遵循了单一职责原则，每个模块都有明确的职责和边界。模块间的接口设计考虑了未来的扩展需求，使用trait来定义抽象接口，确保模块的松耦合。每个模块都包含了基本的测试框架，为后续的测试驱动开发做好准备。

### 测试与示例 ✅

测试与示例部分已经建立：

- **tests/smoke.rs**：提供了冒烟测试，验证项目的基本编译功能
- **examples/hello.c**：提供了基础的测试用例，为后续的功能测试提供参考

这些测试和示例为项目的质量保证奠定了基础。

测试策略采用了分层测试的方法，包括单元测试、集成测试和端到端测试。冒烟测试确保项目能够正常编译和运行，为后续开发提供信心。示例代码涵盖了基本的C语言特性，为功能测试提供了丰富的测试用例。测试框架使用Rust内置的测试支持，支持测试发现、测试执行和测试报告等功能。

## 验证与对齐脚本方案

### 目标

验证与对齐脚本方案的目标是对每个编译阶段（Token、AST、IR、RISC-V汇编）将自研编译器输出与Bisheng官方接口输出进行对比，形成自动化的一致性验证。这个方案将确保我们的编译器与Bisheng工具链的完全兼容性，为后续的集成和部署提供质量保证。

验证方案的设计考虑了多个方面的需求：
- **正确性验证**：确保我们的输出与参考实现完全一致
- **性能验证**：确保我们的编译器在性能上不会显著落后于参考实现
- **兼容性验证**：确保我们的输出能够被后续的工具链正确处理

### 目录结构

验证脚本的目录结构设计合理：

- **scripts目录**：包含了各种对比脚本，如词法对比、AST对比、IR对比和汇编对比等
- **tools目录**：包含了各种工具脚本，如clang输出转JSON、AST归一化、IR规范化和汇编规范化等
- **out目录**：用于存放对比产物和中间文件，便于结果分析和问题诊断

目录结构的设计考虑了脚本的可维护性和可扩展性。每个脚本都有明确的职责和接口，便于独立开发和测试。工具脚本提供了通用的功能支持，可以被多个对比脚本复用。输出目录的组织考虑了文件类型和用途，便于结果的分析和归档。

### 环境要求

环境要求包括：
- 安装Bisheng工具链，确保clang命令可用
- 在scripts/env.sh中配置BISHENG_HOME和PATH环境变量
- 安装LLVM工具，包括opt、llvm-as、llvm-dis等，这些工具用于IR的规范化和处理

环境配置考虑了不同平台的兼容性和工具的可用性。Bisheng工具链提供了完整的编译工具链，包括前端、优化器和后端。LLVM工具提供了丰富的IR处理功能，包括IR的规范化、优化和转换等。环境变量配置使用相对路径和绝对路径相结合的方式，确保脚本在不同环境下都能正常工作。

### CLI约定

CLI约定统一通过cargo run命令执行，提供丰富的--emit选项，支持：
- tokens
- ast
- bisheng-tokens
- bisheng-ast
- bisheng-ir
- ir
- riscv

等多种输出格式。输出默认到stdout，必要时可以通过-o选项指定输出路径，提供了灵活的接口设计。

CLI设计考虑了用户的使用习惯和需求。--emit选项提供了多种输出格式，满足不同阶段的需求。输出路径的灵活性允许用户将结果保存到文件或传递给其他工具。命令行的设计遵循了Unix哲学，每个命令都有明确的输入和输出，便于脚本化和自动化。

### 对比流程

对比流程设计科学：

- **Token对比**：采用JSON格式，按顺序或基于kind/value进行比对
- **AST对比**：采用JSON格式，通过归一化处理后进行深度比较
- **IR对比**：采用文本格式，经过规范化处理后进行diff比较
- **汇编对比**：采用文本格式，去除注释和空白后进行diff比较

这种分阶段的对比方式确保了验证的全面性和准确性。

对比流程的设计考虑了不同数据格式的特点和比较的准确性。JSON格式便于结构化数据的比较，支持深度比较和差异分析。文本格式适合IR和汇编的比较，通过规范化处理减少无关差异的影响。归一化处理包括字段排序、空白去除、注释删除等，确保比较的准确性。

## 构建与运行指南

### 先决条件

构建与运行指南的先决条件包括：
- 安装Rust工具链，建议使用rustup安装stable版本，确保开发环境的一致性
- 安装Bisheng工具链，配置相应的环境变量，为验证和对比提供参考环境
- 安装ANTLR 4工具，用于语法文件解析和代码生成

环境配置的详细步骤包括：
1. 首先安装rustup，这是Rust的官方安装工具，支持多版本管理和工具链切换
2. 然后使用rustup安装stable版本的Rust工具链，包括rustc、cargo等核心工具
3. Bisheng工具链的安装需要下载官方发布包，解压到指定目录，并配置环境变量
4. ANTLR 4工具的安装：
   - 下载ANTLR 4 JAR文件
   - 配置ANTLR4_HOME环境变量
   - 将antlr4命令添加到PATH中
5. 环境变量的配置包括PATH、BISHENG_HOME、ANTLR4_HOME等，确保工具能够被正确找到

### 基本命令

基本命令包括：
- **cargo build**：用于项目构建
- **cargo test**：用于运行测试
- **cargo run**：用于运行程序
- **cargo clean**：用于清理构建产物

这些命令为项目的开发、测试和部署提供了完整的工具链支持。

Cargo是Rust的官方包管理器和构建工具，提供了丰富的功能：
- cargo build支持多种构建模式，包括debug和release模式，支持增量编译和并行编译
- cargo test支持测试发现、测试过滤和测试并行执行
- cargo run支持参数传递和环境变量设置，便于程序的调试和测试
- cargo clean支持选择性清理，可以清理特定的构建产物

### 验证命令

验证命令包括：
- 单文件Token对比
- 批量对比
- 生成特定输出

这些命令为验证脚本的执行提供了接口，支持各种验证场景的需求。

验证命令的设计考虑了不同使用场景的需求。单文件对比适合开发阶段的快速验证，批量对比适合回归测试和持续集成。生成特定输出支持不同格式的输出，便于结果分析和问题诊断。命令的执行支持并行化和错误处理，确保验证过程的效率和可靠性。
